substitutions:
  id: ${id}
  friendly_name: ${name}
  reset_time: "3000000"
  short_signal_time: "200000"
  long_signal_time: "750000"
  monitored_sensor_id: monitored_sensor
  script_execute_on_match: dummy_execute_script
  secret_code_to_match: "" #use S for short press and L for long press, e.g. "SSLLS" for short-short-long-long-short

globals:
  - id: start_time
    type: int
    restore_value: no
    initial_value: "0"
  - id: last_input_time
    type: int
    restore_value: no
    initial_value: "0"
  - id: secret_code
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: secret_code_to_match
    type: std::string
    restore_value: no
    initial_value: "${secret_code_to_match}"

binary_sensor:
  - id: !extend ${monitored_sensor_id}
    on_press:
      then:
        - script.execute: handle_press
    on_release:
      then:
        - script.execute: handle_release

# binary_sensor:
#   - platform: gpio
#     pin:
#       number: GPIO00
#       # mode: INPUT_PULLUP
#       inverted: true
#     name: "Secret Code Switch"
#     on_press:
#       then:
#         - script.execute: handle_press
#     on_release:
#       then:
#         - script.execute: handle_release

script:
  - id: dummy_execute_script
    then:
      - logger.log:
          format: "SECRET CODE MATCHED!! No script was executed but the dummy instead."
          tag: ${id}
          level: WARN
  - id: handle_press
    then:
      - lambda: |-
          if (id(secret_code_to_match).empty()) {
            ESP_LOGD("secret_code", "[handle_press] The secret_code_to_match is empty. Please set a valid secret code to match.");
            return;
          }
          int local_start_time = system_get_time();
          if (local_start_time - id(last_input_time) > ${reset_time}) {
            ESP_LOGI("secret_code", "resetting secret code because reset_time has passed");
            id(secret_code).clear();  // Reset the code after ${reset_time} seconds of no input
          }
          id(start_time) = local_start_time;
  - id: handle_release
    then:
      - lambda: |-
          if (id(secret_code_to_match).empty()) {
            ESP_LOGD("secret_code", "[handle_release] The secret_code_to_match is empty. Please set a valid secret code to match.");
            return;
          }
          int release_time = system_get_time();
          int press_duration = release_time - id(start_time);
          if (press_duration < ${short_signal_time}) {
            id(secret_code).append("S");  // Short press
          } else if (press_duration < ${long_signal_time}) {
            id(secret_code).append("L");  // Long press
          } else {
            id(secret_code).clear();  // Reset the code if the press was longer than ${long_signal_time} ms
          }
          id(last_input_time) = release_time;
          ESP_LOGI("secret_code", "Press began at: %d, stopped at: %d, duration: %d ms", id(start_time), release_time, press_duration);
          ESP_LOGI("secret_code", "Current secret code: %s", id(secret_code).c_str());
          if (id(secret_code) == id(secret_code_to_match)) {
            ESP_LOGI("secret_code", "SECRET CODE [${secret_code_to_match}] MATCHED!! Executing script ${script_execute_on_match}.");
            id(secret_code).clear();  // Reset the code after a successful match
            script.execute(id("${script_execute_on_match}"));
          }
